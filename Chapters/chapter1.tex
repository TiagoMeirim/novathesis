%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter1.tex
%% NOVA thesis document file
%%
%% Chapter with introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter1.tex}%

\chapter{Introduction}
\label{cha:introduction}

%\subsection{Motivation}
%\label{sub:Motivation}

\section{Motivation}
\label{sec:Motivation}


Progress in deductive software verification has been steadily advancing, particularly for formal languages. 
However, the foundational groundwork was laid as early as 1936 by Alan Turing in his seminal paper "On Computable Numbers," 
which introduced key concepts of computation and formal proof. Other notable papers where mathematical propositions were 
established purely through theoretical reasoning include Alan Turing's Systems of Logic Based on Ordinals, Alonzo Church's 
An Unsolvable Problem of Elementary Number Theory and Kurt Gödel's Incompleteness Theorems. These works laid important 
foundations in logic, computation, and formal reasoning without relying on physical implementation or empirical methods.
Our research draws on several key papers that directly influenced deductive software verification and the technologies 
we will use. These include Robin Milner's foundational work on type polymorphism (shaped the ML language) Gordon and 
Melham's Introduction to HOL (formalized higher-order logic for verification) and Xavier Leroy's CompCert (a landmark 
in formally verified compilation)~\cite{Turing37, Turing38}. 
%%https://turingarchive.kings.cam.ac.uk/publications-lectures-and-talks-amtb/amt-b-12
%%https://www.dcc.fc.up.pt/~acm/turing-phd.pdf

%%Revolucao SMT mencionar

Why are verified compilers such an important target for formal verification? If a verified program is compiled by a 
faulty compiler, the resulting executable may not preserve its intended behavior, invalidating the higher-level correctness 
so compilers like CompCert and CakeML address this issue by providing formally verified compilation pipelines
~\cite{LoowKTMNAF19, GrossEPPC22, Leroy09}, thereby eliminating a major source of uncertainty and ensuring that correctness is 
preserved from source code to machine code~\cite{LeroyCompilerMeaning}.
%%https://cakeml.org/pldi19.pdf %%https://arxiv.org/pdf/2205.00862
%%https://xavierleroy.org/publi/compcert-CACM.pdf
%%https://xavierleroy.org/talks/ICALP2016.pdf

Developments in relation to verified code have become increasingly crucial to achieve correctness and provide safety, 
the way we define correctness has more than one definition, it can be specified informally or written in formal language 
~\cite{Filliatre11}. The weight of functional languages for deductive software verification has been quite low despite having
good candidates for verification, like OCaml. Ever since 2018 with the introduction of GOSPEL, with providing
fomal language specification tightly integrated with OCaml, verification has become easier with a modular specification
that doesn't need much changes to OCaml code. This wasn't the first time formal logic and proof has been merged with 
functional programming, previous and more foundational systems like COQ, Agda, F*(F star), Liquid Haskell and WhyML have
paved the way. Now that we have a behavioural specification language for OCaml we can expand this verification for other
funtional languages, that was already done in 2021 with the addition of Cameleer, an automated deductive verification
tool that translates a formally-specified program, like GOSPEL, into the corresping code in WhyML. This innovation in
translation of verified code to other languages gave a new view onto how other functional languages could have their
code verified while being written in a more expressive language just like OCaml. A clear applicant was CakeML, a
language based on a substantial subset of Standard ML, having a core goal of creating an end-to-end verified compiler.


%% Standard menos famoso que OCaml entao ha interesse em construir programas corretos em algo mais mainstream, comparação ao SML
%% Mais verificaçoes em papel, mais sobre compiladores verificados


\section{Problem Definition}
\label{sec:Problem_Definition}

%% Retirar pontos 

Writing precise specifications can turn out to be very challenging, since having an incomplete specification will eventually
make the verification meaningless. PUT SOME RESEARCHES ABOUT SOFTWARE VERIFICATION AND TALK ABOUT HOW THERE ARE NO AUTOMATED VERIFICATION PAPERS.
Despite all the papers above mentioned there are not much papers that go deep inside automated deductive verification.
And then we have CakeML, a research-driven compiler with the main goal of providing a fully proof-producing code generation tool 
that given ML-like functions in higher-order logic (HOL) automatically produces equivalent executable machine code. Analyzing
syntactic and semantic foundations with OCaml we see that both share very similar features most notably, functional core, 
strong static typing, pattern matching and higher-order functions.
Now we are presented with some questions:

- Now that automated deductive verification has a tool that eases translation, could we expand it for even more languages?
- Can CakeML's verified compilation pipeline be generalized to other ML-family languages like WhyML?
- What minimal syntactic and semantic guarantees must a language offer to be compatible with CakeML's verified compiler?
- Could an OCaml-to-HOL4 transpiler (guided by GOSPEL specs) be created to automate CakeML target generation?

\section{Goals and Expected Contribution}
\label{sec:Goals_and_Expected_Contribution}

\section{Report Structure}
\label{sec:Report_Structure}
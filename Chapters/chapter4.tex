%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter4.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter4.tex}%

\chapter{Preliminary Results}
\label{cha:Preliminary_Results}

%%mencionar que alterei a ferramenta do cameleer(adicionei a extracao direta de cameleer para cakeml)
%%Seccao para cada exemplo, apresentar codigo ocaml verificado, codigo traduzido e codigo corrigido se necessario
%%explicar o pedaco de codigo, condicoes do GOSPEL
%%explicar o que alteramos

\subsection{Recursive Factorial}

\begin{gospell}
(*@ 
  function rec factorial (n:int) :int = 
    if n=0 then 1 else n * factorial (n-1)
*)
(*@ 
  requires n >= 0
  variant n
*)
let rec fact_aux n c t =
  if c <= n then fact_aux n (c+1) (t*c) else t
(*@
  r = fact_aux n c t
  requires n >= 0
  requires 0 < c <= n+1
  requires t = factorial (c-1)
  ensures r = factorial n
  variant n-c+1
*)


let fact n = fact_aux n 1 1
(*@ 
  r = fact n
  requires n >= 0 
  ensures r = factorial n
*)
\end{gospell}

Generated code from cameleer to CakeML.

\begin{cakeml}
fun fact_aux n c t = let val n1 = n in
  let val c1 = c in
  let val t1 = t in
  if c1 <= n1 then (fact_aux n1 (c1 + (1)) (t1 * c1))  else (t1)

fun fact n = let val n1 = n in fact_aux n1 (1) (1)
\end{cakeml}

Correct code that CakeML can compile

\begin{cakeml}
fun fact_aux n c t = let val n1 = n in
  let val c1 = c in
  let val t1 = t in
  if c1 <= n1 then (fact_aux n1 (c1 + (1)) (t1 * c1))  else (t1)
  end end end

fun fact n = let val n1 = n in fact_aux n1 (1) (1) end
\end{cakeml}

\subsection{Exception recursive search}

\begin{gospell}
let rec search_aux a c n =
    let exception Break of int in try
        if c = Array.length a then raise Not_found else if a.(c) = n 
        then raise (Break n) else search_aux a (c+1) n
    with Break i -> i
(*@
    r = search_aux a c n
    requires 0 <= c <= Array.length a
    requires forall k. 0 <= k < c -> a.(k) <> n
    raises Not_found -> forall k. 0 <= k < Array.length a -> a.(k) <> n
    ensures r = n
    variant Array.length a - c
*)

let linear_search a n = search_aux a 0 n
(*@
    r = linear_search a n
    raises Not_found -> forall k. 0 <= k < Array.length a -> a.(k) <> n
    ensures r = n
*)
\end{gospell}

Generated code from cameleer to CakeML.

\begin{cakeml}
fun search_aux a c n = let val a1 = a in
  let val c1 = c in
  let val n1 = n in
  let exception Break of (int) in
  ((if c1 = (a1.length) then (raise Not_found) 
    else (if (get a1 c1) = n1 then (raise (Break n1)) 
          else (search_aux a1 (c1 + (1)) n1)))
  handle   Break i => i)

fun linear_search a n =
  let val a1 = a in let val n1 = n in search_aux a1 (0) n1
\end{cakeml}

Correct code that CakeML can compile

\begin{cakeml}

exception Not_found
exception Break int

fun search_aux a c n = let val a1 = a in
  let val c1 = c in
  let val n1 = n in
  ((if c1 = (Array.length a1) then (raise Not_found) 
    else (if (Array.sub  a1 c1) = n1 then (raise (Break n1)) 
          else (search_aux a1 (c1 + (1)) n1)))
  handle Break i => i)
  end end end

fun linear_search a n =
  let val a1 = a in let val n1 = n in search_aux a1 (0) n1 
  end end

\end{cakeml}

\subsection{High-order}

High-order logic code verified through cameleer.

\begin{gospell}
    (*@ function rec map (f: int -> int) (l: int list) : int list = 
            match l with
            | [] -> []
            | h::t -> (f h) :: map f t *)
    (*@ variant l
            ensures List.length result = List.length l *)

    let rec mult_list l n =
        match l with
        | [] -> []
        | h :: t -> n * h :: mult_list t n
    (*@ r = mult_list l n
            ensures r = map (fun x -> x * n) l
            variant l *)
\end{gospell}

Generated code from cameleer to CakeML.

\begin{cakeml}
    fun mult_list l n = let val l1 = l in
        let val n1 = n in
        (case l1 of
            [] => []
        | h :: t => (n1 * h) :: (mult_list t n1))
\end{cakeml}

Correct code that CakeML can compile

\begin{cakeml}
    fun mult_list l n = let val l1 = l in
        let val n1 = n in
        (case l1 of
            [] => []
        | h :: t => (n1 * h) :: (mult_list t n1))
        end end
\end{cakeml}

\subsection{Depth-search tree}

\begin{gospell}
type 'a tree =
    | Leaf
    | Node of 'a tree * 'a * 'a tree

(*@ function rec to_list (t: 'a tree) : 'a list = 
  match t with
  | Leaf -> []
  | Node l x r -> x :: to_list l @ to_list r
*)
(*@
  variant t
*)

let rec depth_search t n = 
  match t with
  | Leaf -> false
  | Node (l,x,r) -> x = n || depth_search l n || depth_search r n
(*@
  r = depth_search t n
  variant t
  ensures List.mem n (to_list t) <-> r
*)
\end{gospell}

Generated code from cameleer to CakeML.

\begin{cakeml}
'a datatype tree = Leaf | Node of 'a tree * 'a * 'a tree

fun depth_search t n = let val t1 = t in
  let val n1 = n in
  (case t1 of
    Leaf => false
  | Node l x r =>
    (x = n1) orelse ((depth_search l n1) orelse (depth_search r n1)))
\end{cakeml}

Correct code that CakeML can compile

\begin{cakeml}
datatype 'a tree = Leaf | Node ('a tree) 'a ('a tree)

fun depth_search t n = let val t1 = t in
  let val n1 = n in
  (case t1 of
    Leaf => False
  | Node l x r =>
    (x = n1) orelse ((depth_search l n1) orelse (depth_search r n1)))
    end end
\end{cakeml}

\subsection{Tree Comparison}

\begin{gospell}
module Tree = struct

  type 'a tree =
    | Leaf
    | Node of 'a tree * 'a * 'a tree

  let rec cmp t1 t2 =
    match t1, t2 with
    | Leaf, Leaf -> true
    | Leaf, _ -> false
    | _, Leaf -> false
    | Node (l1,x1,r1), Node (l2,x2,r2) -> cmp l1 l2 && x1 = x2 && cmp r1 r2
    
  (*@
  r = cmp t1 t2
  variant t1
  ensures r <-> t1 = t2
  *)
end
\end{gospell}

Generated code from cameleer to CakeML.

\begin{cakeml}
'a datatype tree = Leaf | Node of 'a tree * 'a * 'a tree

fun cmp t1 t2 = let val t11 = t1 in
  let val t21 = t2 in
  (case (t11, t21) of
    (Leaf, Leaf) => true
  | (Leaf, _) => false
  | (_, Leaf) => false
  | (Node l1 x1 r1, Node l2 x2 r2) =>
    (cmp l1 l2) andalso ((x1 = x2) andalso (cmp r1 r2)))
\end{cakeml}

Correct code that CakeML can compile

\begin{cakeml}
datatype 'a tree = Leaf | Node ('a tree) 'a ('a tree)

fun cmp t1 t2 = let val t11 = t1 in
  let val t21 = t2 in
  (case (t11, t21) of
    (Leaf, Leaf) => True
  | (Leaf, _) => False
  | (_, Leaf) => False
  | (Node l1 x1 r1, Node l2 x2 r2) =>
    (cmp l1 l2) andalso ((x1 = x2) andalso (cmp r1 r2)))
    end
  end
\end{cakeml}
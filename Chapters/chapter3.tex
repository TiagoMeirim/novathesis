%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter3.tex
%% NOVA thesis document file
%%
%% Chapter with a short latex tutorial and examples
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter3.tex}%

\chapter{State Of The Art}
\label{cha:State_Of_The_Art}

The State-Of-The-Art outlines the most relevant and advanced work currently available in the area covered by this work. 
It provides an overview of existing research, tools, and methodologies, helping to frame the context in which this work is situated. 
By reviewing what has already been accomplished, this section highlights ongoing challenges and uncovers the gaps that this work 
aims to address.

\section{Certified Compilers}
\label{sec:Certified_Compilers}

A compiler is a software system that translates a program written in a source programming language into an equivalent representation 
in a target language, typically a lower-level language such as assembly or machine code. The goal of a compiler is not only to preserve 
the semantics of the original program but also to generate efficient and executable code for the target platform.~\cite{AhoSU86}

A central challenge in compiler technology is: How can we trust compilers?. As discussed previously, compilers are 
inherently complex systems, particularly optimizing compilers, which perform intricate symbolic transformations. 
Despite rigorous testing practices, compilers can still introduce subtle bugs during these transformations. Such bugs are often 
extremely difficult to detect and diagnose~\cite{Leroy09-back-end}, as they may lead to unexpected program crashes, 
incorrect behaviour, or silent miscomputations in the generated code, even when the original source code remains syntactically and 
semantically valid.

This raises serious concerns in the context of safety-critical or high-assurance software, where traditional validation 
through testing alone is insufficient. In such domains, testing must be complemented or in some cases replaced by formal methods, 
such as model checking, static analysis, and deductive program verification~\cite{Leroy09-back-end}.

This is precisely where certified compilers become essential. A certified compiler is accompanied by a machine-checked formal proof 
that guarantees semantic preservation during the transformation from source to target code. It preserves the semantics of the source 
program during its transformation into target code. This approach offers strong assurances about the absence of certain classes of 
errors, such as compilation bugs, compilation inaccuracies, or unsafe optimizations~\cite{Leroy09}. Unlike traditional compilers, 
whose correctness is typically established through empirical testing or informal reasoning, certified compilers provide mathematical 
guarantees of correctness, making them valuable in the development of high-assurance and safety-critical software.

\subsection{CompCert}
\label{sec:CompCert}

The development of a realistic and verified compiler began with CompCert. Here, verified denotes a compiler accompanied by
a machine-checked proof that the generated code behaves exactly as prescribed by the semantics of the source program.
Realistic refers to a compiler that can be effectively employed in the production of critical software systems~\cite{Leroy09-back-end}.

CompCert adopts a multi-pass compilation architecture, where each pass translates an intermediate representation into a lower-level 
form, gradually transforming the high-level C source code into target assembly code. These intermediate languages are Clight, Cminor, 
RTL, LTL, and others which are formally defined within Coq. CompCert's core is implemented in Gallina, the functional programming 
language of Coq, which is based on the Calculus of Inductive Constructions, a powerful higher-order logic and typed $\lambda$-calculus. 
This implementation enables formal reasoning and machine-checked proofs of correctness for each compilation phase~\cite{MonniauxB22}.

Although CompCert is developed in Coq, it is not executed within the proof assistant. Instead, the verified Gallina code is extracted 
to \ocaml, where it is combined with a small portion of handwritten \ocaml code to produce an efficient and executable 
compiler~\cite{MonniauxB22}.

Since the compiler must generate a large subset of the C language, the code needs to be eï¬ƒcient enough and compact enough to fit the 
requirements of critical embedded systems. This implies a multi-pass compiler that features good register allocation and some basic 
optimizations~\cite{Leroy09-back-end}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{images/compcert_diagram.png}
    \caption{CompCert pipeline diagram~\cite{hal-01643290, CompCertPipeline}}
    \label{fig:CompCertPipeline}
\end{figure}

\subsection{CakeML}
\label{sec:CakeML}

The \cml compiler stands out as one of the most realistic verified compilers for functional programming. Inspired by both CompCert 
and \ocaml compilers, it supports a rich set of language features commonly found in unverified compilers for functional languages. The 
main goal of the \cml compiler is to combine end-to-end formal verification with practical performance, making it suitable 
for high-assurance applications without compromising efficiency~\cite{TanMKFON19}. \cml is a formally verified functional programming 
language and compiler toolchain, specifically designed to target practical, off-the-shelf hardware while achieving a high degree of 
trustworthiness. It serves as a robust platform for software in domains where correctness is paramount. By focusing on functional 
programming and end-to-end verification, \cml complements CompCert, which primarily target imperative languages and emphasize 
performance oriented optimizations. Together, these approaches address different but complementary aspects of verified software 
development~\cite{POPL14}.

\cml can also bootstrap its compiler, meaning it can compile itself, in order to be used inside and outside the logic. This 
bootstrapping is performed by generating verified machine code from a formally proven semantics of the compiler, effectively 
closing the trusted computing base gap. This process ensures that the final executable compiler has been produced through a 
chain of correctness preserving transformations, all verified in the HOL4 theorem prover~\cite{TanMKFON19, POPL14}.

Complementing this, \cml adopts a multi-stage compilation pipeline, Each stage of the pipeline transforms an intermediate representation
of the program into a successively lower-level form, progressing from functional language down to executable machine code. The latest 
verified CakeML compiler and pipeline, as of writing this document, goes through 8 intermediate languages and targets machine code 
for 6 architectures.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{images/CakeMLPipeline.png}
    \caption{\cml multi-stage pipeline}
    \label{fig:CakeMLPipeline}
\end{figure}

In the figure \ref{fig:CakeMLPipeline} the red boxes represent all the languages the compiler passes through until it reaches the
encoding for each of the different types of machine code programs, represented as green.

\subsection{PureCake}

Another tool that compiles to \cml code with a verified compiler is PureCake, which is a HOL4-verified compiler for a lazy, 
functional language with Haskell-like, indentation sensitive syntax. Since, the output code is \cml code it can be passed 
through \cml trusted backend, ensuring end-to-end verification~\cite{KanabarVAMNPZ23}.

Inspired by CompCert, it targets a Standard ML-style language and compiles down to \cml through a verified pipeline.
This design not only makes it possible to compile lazy functional programs in a sound and verified way, but also showcases 
how flexible \cml's verified infrastructure can be when adapting to different programming language styles. 
By supporting features that are rarely seen in other verified compilers, PureCake expands the range of languages that can 
benefit from verified compilation, showing that it's feasible to bring formal guarantees even to non-strict, high-level 
functional languages~\cite{KanabarVAMNPZ23, KanabarKM24}.

\section{Pipeline}
\label{sec:Pipeline}

Some parts of the verification pipeline have already been implemented or require only minor adjustments to meet their 
objectives. \cameleer provides translation of \ocaml code annotated with \gospel specifications into \whyml :

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{images/Cameleer.png}
    \caption{\ocaml to \whyml pipeline with \cameleer}
    \label{fig:Cameleer_pipeline}
\end{figure}

The extraction process does not require the correctness of the code to be proven. This may lead to potentially incorrect \ocaml 
programs to be extracted to \cml. Additionally, it is not designed to prevent users from extracting code even if the \gospel 
specifications can not guarantee correctness.

%%Processo de extracao nao esta ligado ao facto de um exemplo ja ter sido provado ou nao, pode potencialmente 
%%levar a gerar codigo cakeml nao correto

By modifying the extraction process in \whythree to check if the proof has been discharged we can provide better correctness 
guarantees because the generated \cml code will comply to the specification. Due to differences in syntax and features that 
have no direct equivalents in \cml, we must also include some kind of error message for failures in extraction, for instance 
the lack of support for while and for loops.

The goal of this work is to expand the currently available pipeline of translating code from \ocaml with \gospel specifications 
into \whyml, where it can be verified using the various automated provers available in Why3. One of our goals is to achieve 
a more robust extraction mechanism with the ideas as previously discussed. Moreover, we ought to provide a new tool that 
translates compilable \cml programs into \ocaml equivalents that can be specified afterwards with \gospel so that one may prove 
their correctness in \cameleer.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{images/Goal_Pipeline.png}
    \caption{Goal pipeline}
\end{figure}



%%existe extracao cameleer para whyml, de whyml para cakeml, whyml para ocaml64